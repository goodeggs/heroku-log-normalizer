// Generated by CoffeeScript 1.7.1
(function() {
  var LEADING_TRIMMER, LRU, MAX_LOG_LINE_BATCH_SIZE, SyslogParser, app, async, extractMessage, http, invalidMessageCache, librato, request, splunkConfig, splunkQueue, syslogMessageToJSON, track, url, _ref;

  SyslogParser = require('glossy').Parse;

  LRU = require('lru-cache');

  librato = require('librato-node');

  async = require('async');

  http = require('http');

  url = require('url');

  request = require('request');

  librato.configure({
    email: process.env.LIBRATO_EMAIL,
    token: process.env.LIBRATO_TOKEN
  });

  librato.start();

  track = function(metric, count) {
    if (count == null) {
      count = 1;
    }
    return librato.increment("production.heroku_log_normalizer." + metric, count);
  };

  splunkConfig = (function() {
    var pass, splunkUri, user, _ref;
    splunkUri = url.parse(process.env.SPLUNK_URI, true);
    _ref = splunkUri.auth.split(':'), user = _ref[0], pass = _ref[1];
    return function() {
      return {
        url: "" + splunkUri.protocol + "//" + splunkUri.host + splunkUri.path,
        method: 'POST',
        auth: {
          user: user,
          pass: pass
        },
        headers: {
          'Content-Type': 'text/plain'
        },
        strictSSL: false
      };
    };
  })();

  MAX_LOG_LINE_BATCH_SIZE = 100;

  splunkQueue = async.cargo(function(messages, cb) {
    var requestConfig;
    requestConfig = splunkConfig();
    requestConfig.qs = {
      sourcetype: 'json_predefined_timestamp'
    };
    requestConfig.body = messages.join("\r\n");
    return request(requestConfig, function(err, res) {
      if ((err != null) || res.statusCode >= 500) {
        console.error(err || ("Error: " + res.statusCode + " response"));
        track('error', messages.length);
        splunkQueue.push(messages);
      } else {
        track('outgoing', messages.length);
      }
      return cb();
    });
  }, MAX_LOG_LINE_BATCH_SIZE);

  invalidMessageCache = LRU(100);

  extractMessage = function(syslogMessage, parser) {
    var current, e, key, msg;
    try {
      return parser(syslogMessage.message);
    } catch (_error) {
      e = _error;
      key = [syslogMessage.host, syslogMessage.pid, syslogMessage.time].join('|');
      if ((current = invalidMessageCache.get(key)) != null) {
        current += syslogMessage.message;
        try {
          msg = parser(current);
          track('reconstructed');
          return msg;
        } catch (_error) {
          e = _error;
          invalidMessageCache.set(key, current);
        }
      } else {
        invalidMessageCache.set(key, syslogMessage.message);
      }
    }
    return null;
  };

  LEADING_TRIMMER = /^[^<]+/;

  syslogMessageToJSON = function(syslogMessage) {
    var parsed, result;
    parsed = SyslogParser.parse(syslogMessage.replace(LEADING_TRIMMER, ''));
    result = (function() {
      switch (parsed.appName) {
        case 'heroku':
          return extractMessage(parsed, (function(msg) {
            return {
              msg: msg
            };
          }));
        case 'app':
          return extractMessage(parsed, JSON.parse);
        default:
          return {
            msg: parsed.message,
            timestamp: new Date().toISOString()
          };
      }
    })();
    if (result == null) {
      return null;
    }
    if (result.timestamp == null) {
      result.timestamp = result.time || parsed.time.toISOString();
    }
    delete result.time;
    delete parsed.originalMessage;
    delete parsed.message;
    result.syslog = parsed;
    return result;
  };

  app = http.createServer(function(req, res) {
    var data, e, urlParts, _ref;
    try {
      urlParts = url.parse(req.url);
      if (urlParts.path.indexOf("/drain") === 0) {
        data = '';
        req.on('data', function(chunk) {
          return data += chunk;
        });
        return req.on('end', function() {
          var json, syslogMessage, syslogMessages, _i, _len, _results;
          res.writeHead(200);
          res.end();
          syslogMessages = data.indexOf("\n") > -1 ? data.split("\n") : [data, ""];
          syslogMessages.pop();
          if (syslogMessages.length) {
            track('incoming', syslogMessages.length);
            _results = [];
            for (_i = 0, _len = syslogMessages.length; _i < _len; _i++) {
              syslogMessage = syslogMessages[_i];
              if (json = syslogMessageToJSON(syslogMessage)) {
                _results.push(splunkQueue.push(JSON.stringify(json)));
              } else {
                _results.push(track('invalid'));
              }
            }
            return _results;
          }
        });
      } else {
        res.writeHead(404);
        return res.end();
      }
    } catch (_error) {
      e = _error;
      console.error((_ref = e.stack) != null ? _ref : e);
      res.writeHead(503);
      return res.end();
    }
  });

  app.listen((_ref = process.env.PORT) != null ? _ref : 8000);

  process.on('SIGINT', function() {
    console.error('Got SIGINT.  Exiting.');
    return app.close(function() {
      var pollInterval;
      if (splunkQueue.length()) {
        console.error('Waiting for splunk queue to drain...');
        pollInterval = setInterval((function() {
          return console.error("" + (splunkQueue.length()) + " messages left to send");
        }), 1000);
        return splunkQueue.drain = function() {
          clearInterval(pollInterval);
          console.error('drained!');
          return process.exit(0);
        };
      } else {
        return process.exit(0);
      }
    });
  });

}).call(this);
