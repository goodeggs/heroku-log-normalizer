// Generated by CoffeeScript 1.6.3
(function() {
  var LRU, LogFmt, SyslogParser, argv, extractMessage, fibrous, invalidMessageCache, librato, redis, redisClient, running, syslogMessageToJSON, track;

  SyslogParser = require('glossy').Parse;

  LogFmt = require('logfmt');

  LRU = require('lru-cache');

  librato = require('librato-node');

  redis = require('redis');

  fibrous = require('fibrous');

  argv = require('optimist').usage('Read syslog lines from the given redis list, normalize them to JSON, and write them to stdout.\nUsage: $0').demand('l').alias('l', 'list').describe('l', 'list key').alias('p', 'port').describe('p', 'redis port').alias('h', 'host').describe('h', 'redis host')["default"]({
    p: 6379,
    h: '127.0.0.1'
  }).argv;

  running = true;

  librato.configure({
    email: process.env.LIBRATO_EMAIL,
    token: process.env.LIBRATO_TOKEN
  });

  librato.start();

  redisClient = redis.createClient(argv.port, argv.host);

  redisClient.on('error', function(err) {
    return console.error(err);
  });

  track = function(metric) {
    return librato.increment("production.heroku_log_normalizer." + metric);
  };

  invalidMessageCache = LRU(100);

  extractMessage = function(syslogMessage, parser) {
    var current, e, key, msg;
    try {
      return parser(syslogMessage.message);
    } catch (_error) {
      e = _error;
      track('invalid');
      key = [syslogMessage.host, syslogMessage.pid, syslogMessage.time].join('|');
      if ((current = invalidMessageCache.get(key)) != null) {
        current += syslogMessage.message;
        try {
          msg = parser(current);
          track('reconstructed');
          return msg;
        } catch (_error) {
          e = _error;
          invalidMessageCache.set(key, current);
        }
      } else {
        invalidMessageCache.set(key, syslogMessage.message);
      }
    }
    return null;
  };

  syslogMessageToJSON = function(syslogMessage) {
    var parsed, result;
    parsed = SyslogParser.parse(syslogMessage);
    result = (function() {
      switch (parsed.appName) {
        case 'heroku':
          return extractMessage(parsed, LogFmt.parse);
        case 'app':
          return extractMessage(parsed, JSON.parse);
        default:
          return {
            msg: parsed.message,
            timestamp: new Date().toISOString()
          };
      }
    })();
    if (result == null) {
      return null;
    }
    if (result.timestamp == null) {
      result.timestamp = result.time;
    }
    delete result.time;
    delete parsed.originalMessage;
    delete parsed.message;
    result.syslog = parsed;
    return result;
  };

  fibrous.sleep = function(timeoutMs) {
    var future;
    future = new fibrous.Future();
    setTimeout(future["return"].bind(future), timeoutMs);
    return future.wait();
  };

  fibrous.run(function() {
    var e, json, syslogMessage;
    while (running) {
      while (running && redisClient.connected) {
        try {
          syslogMessage = redisClient.rpop.sync.call(redisClient, argv.list);
          if (syslogMessage == null) {
            break;
          }
          track('incoming');
          json = syslogMessageToJSON(syslogMessage);
          if (json == null) {
            break;
          }
          console.log(JSON.stringify(json));
          track('outgoing');
        } catch (_error) {
          e = _error;
          console.error(e);
        }
      }
      fibrous.sleep(500);
    }
    return null;
  });

  process.on('SIGINT', function() {
    console.error('Got SIGINT.  Exiting.');
    running = false;
    librato.stop();
    redisClient.quit();
    return process.exit(0);
  });

}).call(this);
